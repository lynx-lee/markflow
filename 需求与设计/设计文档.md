# MarkFlow - Markdown æ–‡æ¡£ç¼–è¾‘å™¨

> ä¸€ä¸ªåŠŸèƒ½å¼ºå¤§çš„åœ¨çº¿ Markdown ç¼–è¾‘å™¨ï¼Œæ”¯æŒå®æ—¶é¢„è§ˆå¹¶å¯¼å‡ºä¸º Word / Excel / PDF ç­‰æ ¼å¼ã€‚

---

## ğŸ“ é¡¹ç›®ç»“æ„

```
markflow/
â”œâ”€â”€ package.json
â”œâ”€â”€ tsconfig.json
â”œâ”€â”€ vite.config.ts
â”œâ”€â”€ .env
â”œâ”€â”€ .gitignore
â”œâ”€â”€ README.md
â”‚
â”œâ”€â”€ public/
â”‚   â””â”€â”€ favicon.ico
â”‚
â”œâ”€â”€ server/                          # åç«¯æœåŠ¡ (Node.js + Express)
â”‚   â”œâ”€â”€ package.json
â”‚   â”œâ”€â”€ tsconfig.json
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ index.ts                 # æœåŠ¡å…¥å£
â”‚   â”‚   â”œâ”€â”€ routes/
â”‚   â”‚   â”‚   â”œâ”€â”€ export.routes.ts     # å¯¼å‡ºç›¸å…³è·¯ç”±
â”‚   â”‚   â”‚   â””â”€â”€ document.routes.ts   # æ–‡æ¡£ CRUD è·¯ç”±
â”‚   â”‚   â”œâ”€â”€ controllers/
â”‚   â”‚   â”‚   â”œâ”€â”€ export.controller.ts
â”‚   â”‚   â”‚   â””â”€â”€ document.controller.ts
â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”‚   â”œâ”€â”€ word.service.ts      # Word å¯¼å‡ºæœåŠ¡
â”‚   â”‚   â”‚   â”œâ”€â”€ excel.service.ts     # Excel å¯¼å‡ºæœåŠ¡
â”‚   â”‚   â”‚   â”œâ”€â”€ pdf.service.ts       # PDF å¯¼å‡ºæœåŠ¡
â”‚   â”‚   â”‚   â”œâ”€â”€ html.service.ts      # HTML å¯¼å‡ºæœåŠ¡
â”‚   â”‚   â”‚   â””â”€â”€ markdown.service.ts  # Markdown è§£ææœåŠ¡
â”‚   â”‚   â”œâ”€â”€ middlewares/
â”‚   â”‚   â”‚   â”œâ”€â”€ error.middleware.ts
â”‚   â”‚   â”‚   â””â”€â”€ upload.middleware.ts
â”‚   â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”‚   â””â”€â”€ document.model.ts
â”‚   â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”‚   â”œâ”€â”€ converter.ts
â”‚   â”‚   â”‚   â””â”€â”€ logger.ts
â”‚   â”‚   â””â”€â”€ config/
â”‚   â”‚       â””â”€â”€ index.ts
â”‚   â””â”€â”€ templates/
â”‚       â”œâ”€â”€ word-template.ts
â”‚       â””â”€â”€ excel-template.ts
â”‚
â”œâ”€â”€ src/                              # å‰ç«¯ (React + TypeScript)
â”‚   â”œâ”€â”€ main.tsx
â”‚   â”œâ”€â”€ App.tsx
â”‚   â”œâ”€â”€ vite-env.d.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ Layout/
â”‚   â”‚   â”‚   â”œâ”€â”€ Header.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ Sidebar.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ Footer.tsx
â”‚   â”‚   â”‚   â””â”€â”€ Layout.tsx
â”‚   â”‚   â”œâ”€â”€ Editor/
â”‚   â”‚   â”‚   â”œâ”€â”€ MarkdownEditor.tsx       # æ ¸å¿ƒç¼–è¾‘å™¨ç»„ä»¶
â”‚   â”‚   â”‚   â”œâ”€â”€ EditorToolbar.tsx        # ç¼–è¾‘å™¨å·¥å…·æ 
â”‚   â”‚   â”‚   â”œâ”€â”€ PreviewPanel.tsx         # é¢„è§ˆé¢æ¿
â”‚   â”‚   â”‚   â”œâ”€â”€ SplitView.tsx            # åˆ†å±è§†å›¾
â”‚   â”‚   â”‚   â””â”€â”€ CodeMirrorEditor.tsx     # CodeMirror å°è£…
â”‚   â”‚   â”œâ”€â”€ Export/
â”‚   â”‚   â”‚   â”œâ”€â”€ ExportDialog.tsx         # å¯¼å‡ºå¯¹è¯æ¡†
â”‚   â”‚   â”‚   â”œâ”€â”€ ExportButton.tsx
â”‚   â”‚   â”‚   â””â”€â”€ FormatSelector.tsx       # æ ¼å¼é€‰æ‹©å™¨
â”‚   â”‚   â”œâ”€â”€ FileManager/
â”‚   â”‚   â”‚   â”œâ”€â”€ FileList.tsx             # æ–‡ä»¶åˆ—è¡¨
â”‚   â”‚   â”‚   â”œâ”€â”€ FileItem.tsx
â”‚   â”‚   â”‚   â””â”€â”€ FileUploader.tsx         # æ–‡ä»¶ä¸Šä¼ 
â”‚   â”‚   â”œâ”€â”€ Theme/
â”‚   â”‚   â”‚   â””â”€â”€ ThemeToggle.tsx          # ä¸»é¢˜åˆ‡æ¢
â”‚   â”‚   â””â”€â”€ Common/
â”‚   â”‚       â”œâ”€â”€ Button.tsx
â”‚   â”‚       â”œâ”€â”€ Modal.tsx
â”‚   â”‚       â”œâ”€â”€ Toast.tsx
â”‚   â”‚       â”œâ”€â”€ Dropdown.tsx
â”‚   â”‚       â””â”€â”€ Loading.tsx
â”‚   â”‚
â”‚   â”œâ”€â”€ pages/
â”‚   â”‚   â”œâ”€â”€ Home.tsx
â”‚   â”‚   â”œâ”€â”€ EditorPage.tsx
â”‚   â”‚   â””â”€â”€ NotFound.tsx
â”‚   â”‚
â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â”œâ”€â”€ useMarkdown.ts              # Markdown å¤„ç† Hook
â”‚   â”‚   â”œâ”€â”€ useExport.ts                # å¯¼å‡º Hook
â”‚   â”‚   â”œâ”€â”€ useAutoSave.ts              # è‡ªåŠ¨ä¿å­˜ Hook
â”‚   â”‚   â”œâ”€â”€ useLocalStorage.ts
â”‚   â”‚   â”œâ”€â”€ useTheme.ts
â”‚   â”‚   â””â”€â”€ useKeyboardShortcuts.ts     # å¿«æ·é”® Hook
â”‚   â”‚
â”‚   â”œâ”€â”€ stores/
â”‚   â”‚   â”œâ”€â”€ editorStore.ts              # Zustand ç¼–è¾‘å™¨çŠ¶æ€
â”‚   â”‚   â”œâ”€â”€ documentStore.ts
â”‚   â”‚   â””â”€â”€ uiStore.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ api.ts                      # Axios å®ä¾‹
â”‚   â”‚   â”œâ”€â”€ export.api.ts
â”‚   â”‚   â””â”€â”€ document.api.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ styles/
â”‚   â”‚   â”œâ”€â”€ globals.css
â”‚   â”‚   â”œâ”€â”€ editor.css
â”‚   â”‚   â”œâ”€â”€ markdown-preview.css        # Markdown æ¸²æŸ“æ ·å¼
â”‚   â”‚   â””â”€â”€ themes/
â”‚   â”‚       â”œâ”€â”€ light.css
â”‚   â”‚       â””â”€â”€ dark.css
â”‚   â”‚
â”‚   â”œâ”€â”€ types/
â”‚   â”‚   â”œâ”€â”€ editor.d.ts
â”‚   â”‚   â”œâ”€â”€ document.d.ts
â”‚   â”‚   â””â”€â”€ export.d.ts
â”‚   â”‚
â”‚   â””â”€â”€ utils/
â”‚       â”œâ”€â”€ markdownParser.ts
â”‚       â”œâ”€â”€ fileHelper.ts
â”‚       â”œâ”€â”€ shortcuts.ts
â”‚       â””â”€â”€ constants.ts
â”‚
â””â”€â”€ tests/
    â”œâ”€â”€ components/
    â”‚   â””â”€â”€ MarkdownEditor.test.tsx
    â”œâ”€â”€ services/
    â”‚   â”œâ”€â”€ word.service.test.ts
    â”‚   â””â”€â”€ excel.service.test.ts
    â””â”€â”€ utils/
        â””â”€â”€ markdownParser.test.ts
```

---

## ğŸ›  æŠ€æœ¯æ ˆ

### å‰ç«¯

| æŠ€æœ¯ | ç”¨é€” |
|------|------|
| **React 18** | UI æ¡†æ¶ |
| **TypeScript** | ç±»å‹å®‰å…¨ |
| **Vite** | æ„å»ºå·¥å…· |
| **CodeMirror 6** | ä»£ç ç¼–è¾‘å™¨å†…æ ¸ |
| **marked / remark** | Markdown è§£æ |
| **highlight.js** | ä»£ç é«˜äº® |
| **Zustand** | çŠ¶æ€ç®¡ç† |
| **Tailwind CSS** | æ ·å¼æ¡†æ¶ |
| **React Router** | è·¯ç”± |
| **Axios** | HTTP è¯·æ±‚ |
| **react-split-pane** | åˆ†å±å¸ƒå±€ |

### åç«¯

| æŠ€æœ¯ | ç”¨é€” |
|------|------|
| **Node.js + Express** | åç«¯æ¡†æ¶ |
| **TypeScript** | ç±»å‹å®‰å…¨ |
| **docx** | ç”Ÿæˆ Word æ–‡æ¡£ |
| **exceljs** | ç”Ÿæˆ Excel æ–‡æ¡£ |
| **puppeteer** | ç”Ÿæˆ PDF |
| **unified/remark/rehype** | Markdown AST å¤„ç† |
| **SQLite / LowDB** | è½»é‡çº§æŒä¹…åŒ– (å¯é€‰) |

---

## ğŸ“¦ æ ¸å¿ƒä¾èµ–

### `package.json` (å‰ç«¯)

```json
{
  "name": "markflow",
  "version": "1.0.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "server": "cd server && npm run dev",
    "dev:all": "concurrently \"npm run dev\" \"npm run server\"",
    "test": "vitest",
    "lint": "eslint . --ext ts,tsx"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.20.0",
    "@codemirror/lang-markdown": "^6.2.0",
    "@codemirror/state": "^6.3.0",
    "@codemirror/view": "^6.22.0",
    "codemirror": "^6.0.1",
    "marked": "^11.0.0",
    "highlight.js": "^11.9.0",
    "zustand": "^4.4.7",
    "axios": "^1.6.2",
    "react-split-pane": "^0.1.92",
    "react-icons": "^4.12.0",
    "dompurify": "^3.0.6",
    "file-saver": "^2.0.5",
    "mermaid": "^10.6.0"
  },
  "devDependencies": {
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.0",
    "@vitejs/plugin-react": "^4.2.0",
    "typescript": "^5.3.0",
    "vite": "^5.0.0",
    "tailwindcss": "^3.3.0",
    "autoprefixer": "^10.4.0",
    "postcss": "^8.4.0",
    "vitest": "^1.0.0",
    "concurrently": "^8.2.0",
    "eslint": "^8.55.0"
  }
}
```

### `server/package.json` (åç«¯)

```json
{
  "name": "markflow-server",
  "version": "1.0.0",
  "scripts": {
    "dev": "tsx watch src/index.ts",
    "build": "tsc",
    "start": "node dist/index.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "cors": "^2.8.5",
    "docx": "^8.5.0",
    "exceljs": "^4.4.0",
    "puppeteer": "^21.6.0",
    "unified": "^11.0.0",
    "remark-parse": "^11.0.0",
    "remark-rehype": "^11.0.0",
    "rehype-stringify": "^10.0.0",
    "remark-gfm": "^4.0.0",
    "marked": "^11.0.0",
    "multer": "^1.4.5-lts.1",
    "lowdb": "^7.0.0",
    "nanoid": "^5.0.0",
    "helmet": "^7.1.0",
    "morgan": "^1.10.0"
  },
  "devDependencies": {
    "@types/express": "^4.17.21",
    "@types/cors": "^2.8.17",
    "typescript": "^5.3.0",
    "tsx": "^4.6.0"
  }
}
```

---

## ğŸ”‘ æ ¸å¿ƒä»£ç å®ç°

### 1. å‰ç«¯ - ä¸»ç¼–è¾‘å™¨ç»„ä»¶

```tsx
// src/components/Editor/MarkdownEditor.tsx
import React, { useCallback, useRef, useEffect } from 'react';
import { EditorView, keymap, lineNumbers, highlightActiveLine } from '@codemirror/view';
import { EditorState } from '@codemirror/state';
import { markdown, markdownLanguage } from '@codemirror/lang-markdown';
import { defaultKeymap, history, historyKeymap } from '@codemirror/commands';
import { oneDark } from '@codemirror/theme-one-dark';
import { useEditorStore } from '../../stores/editorStore';
import { useTheme } from '../../hooks/useTheme';

interface MarkdownEditorProps {
  initialValue?: string;
  onChange?: (value: string) => void;
}

const MarkdownEditor: React.FC<MarkdownEditorProps> = ({ 
  initialValue = '', 
  onChange 
}) => {
  const editorRef = useRef<HTMLDivElement>(null);
  const viewRef = useRef<EditorView | null>(null);
  const { theme } = useTheme();
  const { setContent, setWordCount } = useEditorStore();

  const handleChange = useCallback(
    (value: string) => {
      setContent(value);
      setWordCount(value.trim().split(/\s+/).filter(Boolean).length);
      onChange?.(value);
    },
    [onChange, setContent, setWordCount]
  );

  useEffect(() => {
    if (!editorRef.current) return;

    const extensions = [
      lineNumbers(),
      highlightActiveLine(),
      history(),
      markdown({ base: markdownLanguage }),
      keymap.of([...defaultKeymap, ...historyKeymap]),
      EditorView.updateListener.of((update) => {
        if (update.docChanged) {
          handleChange(update.state.doc.toString());
        }
      }),
      EditorView.lineWrapping,
      ...(theme === 'dark' ? [oneDark] : []),
    ];

    const state = EditorState.create({
      doc: initialValue,
      extensions,
    });

    const view = new EditorView({
      state,
      parent: editorRef.current,
    });

    viewRef.current = view;

    return () => {
      view.destroy();
    };
  }, [theme]);

  return (
    <div className="editor-container h-full overflow-auto">
      <div ref={editorRef} className="h-full" />
    </div>
  );
};

export default MarkdownEditor;
```

### 2. å‰ç«¯ - é¢„è§ˆé¢æ¿

```tsx
// src/components/Editor/PreviewPanel.tsx
import React, { useMemo } from 'react';
import { marked } from 'marked';
import hljs from 'highlight.js';
import DOMPurify from 'dompurify';
import { useEditorStore } from '../../stores/editorStore';
import 'highlight.js/styles/github-dark.css';

// é…ç½® marked
marked.setOptions({
  renderer: new marked.Renderer(),
  gfm: true,       // GitHub Flavored Markdown
  breaks: true,
  pedantic: false,
  highlight: (code, lang) => {
    if (lang && hljs.getLanguage(lang)) {
      return hljs.highlight(code, { language: lang }).value;
    }
    return hljs.highlightAuto(code).value;
  },
});

const PreviewPanel: React.FC = () => {
  const { content } = useEditorStore();

  const htmlContent = useMemo(() => {
    const raw = marked.parse(content) as string;
    return DOMPurify.sanitize(raw, {
      ADD_TAGS: ['iframe'],
      ADD_ATTR: ['allow', 'allowfullscreen', 'frameborder', 'scrolling'],
    });
  }, [content]);

  return (
    <div className="preview-panel h-full overflow-auto bg-white dark:bg-gray-900 p-8">
      <article
        className="markdown-body prose prose-lg dark:prose-invert max-w-none"
        dangerouslySetInnerHTML={{ __html: htmlContent }}
      />
    </div>
  );
};

export default PreviewPanel;
```

### 3. å‰ç«¯ - åˆ†å±è§†å›¾

```tsx
// src/components/Editor/SplitView.tsx
import React, { useState } from 'react';
import MarkdownEditor from './MarkdownEditor';
import PreviewPanel from './PreviewPanel';
import EditorToolbar from './EditorToolbar';

type ViewMode = 'split' | 'editor' | 'preview';

const SplitView: React.FC = () => {
  const [viewMode, setViewMode] = useState<ViewMode>('split');
  const [splitRatio, setSplitRatio] = useState(50); // ç™¾åˆ†æ¯”

  return (
    <div className="flex flex-col h-full">
      {/* å·¥å…·æ  */}
      <EditorToolbar viewMode={viewMode} onViewModeChange={setViewMode} />
      
      {/* ç¼–è¾‘åŒºåŸŸ */}
      <div className="flex flex-1 overflow-hidden">
        {/* ç¼–è¾‘å™¨ */}
        {(viewMode === 'split' || viewMode === 'editor') && (
          <div
            className="h-full overflow-hidden border-r border-gray-200 dark:border-gray-700"
            style={{
              width: viewMode === 'split' ? `${splitRatio}%` : '100%',
            }}
          >
            <MarkdownEditor />
          </div>
        )}

        {/* å¯æ‹–æ‹½åˆ†éš”æ¡ */}
        {viewMode === 'split' && (
          <div
            className="w-1 cursor-col-resize bg-gray-300 dark:bg-gray-600 
                       hover:bg-blue-500 transition-colors"
            onMouseDown={(e) => {
              const startX = e.clientX;
              const startRatio = splitRatio;
              const container = e.currentTarget.parentElement!;
              const totalWidth = container.offsetWidth;

              const onMouseMove = (ev: MouseEvent) => {
                const delta = ev.clientX - startX;
                const newRatio = startRatio + (delta / totalWidth) * 100;
                setSplitRatio(Math.min(Math.max(newRatio, 20), 80));
              };

              const onMouseUp = () => {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
              };

              document.addEventListener('mousemove', onMouseMove);
              document.addEventListener('mouseup', onMouseUp);
            }}
          />
        )}

        {/* é¢„è§ˆ */}
        {(viewMode === 'split' || viewMode === 'preview') && (
          <div
            className="h-full overflow-hidden"
            style={{
              width: viewMode === 'split' ? `${100 - splitRatio}%` : '100%',
            }}
          >
            <PreviewPanel />
          </div>
        )}
      </div>
    </div>
  );
};

export default SplitView;
```

### 4. å‰ç«¯ - ç¼–è¾‘å™¨å·¥å…·æ 

```tsx
// src/components/Editor/EditorToolbar.tsx
import React from 'react';
import {
  FiBold, FiItalic, FiCode, FiLink, FiImage, FiList,
  FiColumns, FiEdit3, FiEye, FiDownload, FiSave,
  FiSun, FiMoon
} from 'react-icons/fi';
import ExportButton from '../Export/ExportButton';
import { useEditorStore } from '../../stores/editorStore';
import { useTheme } from '../../hooks/useTheme';

type ViewMode = 'split' | 'editor' | 'preview';

interface EditorToolbarProps {
  viewMode: ViewMode;
  onViewModeChange: (mode: ViewMode) => void;
}

const ToolbarButton: React.FC<{
  icon: React.ReactNode;
  label: string;
  active?: boolean;
  onClick: () => void;
}> = ({ icon, label, active, onClick }) => (
  <button
    title={label}
    onClick={onClick}
    className={`p-2 rounded-md transition-colors
      ${active 
        ? 'bg-blue-100 text-blue-600 dark:bg-blue-900 dark:text-blue-300' 
        : 'text-gray-600 hover:bg-gray-100 dark:text-gray-300 dark:hover:bg-gray-700'
      }`}
  >
    {icon}
  </button>
);

const EditorToolbar: React.FC<EditorToolbarProps> = ({ viewMode, onViewModeChange }) => {
  const { wordCount, insertText } = useEditorStore();
  const { theme, toggleTheme } = useTheme();

  const markdownActions = [
    { icon: <FiBold size={16} />, label: 'ç²—ä½“ (Ctrl+B)', insert: '**ç²—ä½“æ–‡æœ¬**' },
    { icon: <FiItalic size={16} />, label: 'æ–œä½“ (Ctrl+I)', insert: '*æ–œä½“æ–‡æœ¬*' },
    { icon: <FiCode size={16} />, label: 'è¡Œå†…ä»£ç ', insert: '`ä»£ç `' },
    { icon: <FiLink size={16} />, label: 'é“¾æ¥', insert: '[é“¾æ¥æ–‡æœ¬](https://)' },
    { icon: <FiImage size={16} />, label: 'å›¾ç‰‡', insert: '![alt](image-url)' },
    { icon: <FiList size={16} />, label: 'åˆ—è¡¨', insert: '\n- åˆ—è¡¨é¡¹\n- åˆ—è¡¨é¡¹\n' },
  ];

  return (
    <div className="flex items-center justify-between px-4 py-2 
                    border-b border-gray-200 dark:border-gray-700 
                    bg-white dark:bg-gray-800">
      {/* å·¦ä¾§ - Markdown å¿«æ·æ“ä½œ */}
      <div className="flex items-center gap-1">
        {markdownActions.map((action, i) => (
          <ToolbarButton
            key={i}
            icon={action.icon}
            label={action.label}
            onClick={() => insertText(action.insert)}
          />
        ))}

        <div className="w-px h-6 bg-gray-300 dark:bg-gray-600 mx-2" />

        {/* è¡¨æ ¼å¿«æ·æ’å…¥ */}
        <ToolbarButton
          icon={<span className="text-xs font-bold">T</span>}
          label="æ’å…¥è¡¨æ ¼"
          onClick={() =>
            insertText(
              '\n| åˆ—1 | åˆ—2 | åˆ—3 |\n| --- | --- | --- |\n| å†…å®¹ | å†…å®¹ | å†…å®¹ |\n'
            )
          }
        />
      </div>

      {/* ä¸­é—´ - è§†å›¾åˆ‡æ¢ */}
      <div className="flex items-center gap-1 bg-gray-100 dark:bg-gray-700 rounded-lg p-1">
        <ToolbarButton
          icon={<FiEdit3 size={14} />}
          label="ä»…ç¼–è¾‘"
          active={viewMode === 'editor'}
          onClick={() => onViewModeChange('editor')}
        />
        <ToolbarButton
          icon={<FiColumns size={14} />}
          label="åˆ†å±"
          active={viewMode === 'split'}
          onClick={() => onViewModeChange('split')}
        />
        <ToolbarButton
          icon={<FiEye size={14} />}
          label="ä»…é¢„è§ˆ"
          active={viewMode === 'preview'}
          onClick={() => onViewModeChange('preview')}
        />
      </div>

      {/* å³ä¾§ - åŠŸèƒ½æŒ‰é’® */}
      <div className="flex items-center gap-2">
        <span className="text-xs text-gray-400">{wordCount} å­—</span>
        
        <ToolbarButton
          icon={theme === 'dark' ? <FiSun size={16} /> : <FiMoon size={16} />}
          label="åˆ‡æ¢ä¸»é¢˜"
          onClick={toggleTheme}
        />

        <ExportButton />
      </div>
    </div>
  );
};

export default EditorToolbar;
```

### 5. å‰ç«¯ - å¯¼å‡ºå¯¹è¯æ¡†

```tsx
// src/components/Export/ExportDialog.tsx
import React, { useState } from 'react';
import { FiFileText, FiGrid, FiFile, FiCode, FiDownload } from 'react-icons/fi';
import { useExport } from '../../hooks/useExport';
import Modal from '../Common/Modal';

interface ExportDialogProps {
  isOpen: boolean;
  onClose: () => void;
}

type ExportFormat = 'docx' | 'xlsx' | 'pdf' | 'html' | 'md';

interface FormatOption {
  id: ExportFormat;
  label: string;
  description: string;
  icon: React.ReactNode;
}

const formatOptions: FormatOption[] = [
  {
    id: 'docx',
    label: 'Word (.docx)',
    description: 'å¯¼å‡ºä¸º Microsoft Word æ–‡æ¡£ï¼Œä¿ç•™æ ‡é¢˜ã€åˆ—è¡¨ã€è¡¨æ ¼ç­‰æ ¼å¼',
    icon: <FiFileText className="text-blue-500" size={28} />,
  },
  {
    id: 'xlsx',
    label: 'Excel (.xlsx)',
    description: 'å°† Markdown ä¸­çš„è¡¨æ ¼æ•°æ®å¯¼å‡ºä¸º Excel å·¥ä½œè¡¨',
    icon: <FiGrid className="text-green-500" size={28} />,
  },
  {
    id: 'pdf',
    label: 'PDF (.pdf)',
    description: 'å¯¼å‡ºä¸º PDF æ–‡æ¡£ï¼Œé€‚åˆæ‰“å°å’Œåˆ†äº«',
    icon: <FiFile className="text-red-500" size={28} />,
  },
  {
    id: 'html',
    label: 'HTML (.html)',
    description: 'å¯¼å‡ºä¸ºå®Œæ•´çš„ HTML é¡µé¢ï¼ŒåŒ…å«æ ·å¼',
    icon: <FiCode className="text-orange-500" size={28} />,
  },
  {
    id: 'md',
    label: 'Markdown (.md)',
    description: 'ä¿å­˜åŸå§‹ Markdown æ–‡ä»¶',
    icon: <FiFileText className="text-purple-500" size={28} />,
  },
];

const ExportDialog: React.FC<ExportDialogProps> = ({ isOpen, onClose }) => {
  const [selectedFormat, setSelectedFormat] = useState<ExportFormat>('docx');
  const [fileName, setFileName] = useState('untitled');
  const [isExporting, setIsExporting] = useState(false);
  const { exportDocument } = useExport();

  const handleExport = async () => {
    setIsExporting(true);
    try {
      await exportDocument(selectedFormat, fileName);
      onClose();
    } catch (error) {
      console.error('Export failed:', error);
    } finally {
      setIsExporting(false);
    }
  };

  return (
    <Modal isOpen={isOpen} onClose={onClose} title="å¯¼å‡ºæ–‡æ¡£">
      <div className="space-y-6">
        {/* æ–‡ä»¶å */}
        <div>
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
            æ–‡ä»¶å
          </label>
          <input
            type="text"
            value={fileName}
            onChange={(e) => setFileName(e.target.value)}
            className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 
                       rounded-lg bg-white dark:bg-gray-700 
                       text-gray-900 dark:text-white
                       focus:ring-2 focus:ring-blue-500 focus:border-transparent"
            placeholder="è¾“å…¥æ–‡ä»¶å..."
          />
        </div>

        {/* æ ¼å¼é€‰æ‹© */}
        <div>
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
            å¯¼å‡ºæ ¼å¼
          </label>
          <div className="grid grid-cols-1 gap-3">
            {formatOptions.map((format) => (
              <div
                key={format.id}
                onClick={() => setSelectedFormat(format.id)}
                className={`flex items-center gap-4 p-4 rounded-lg border-2 cursor-pointer
                  transition-all duration-200
                  ${selectedFormat === format.id
                    ? 'border-blue-500 bg-blue-50 dark:bg-blue-900/20'
                    : 'border-gray-200 dark:border-gray-600 hover:border-gray-300'
                  }`}
              >
                {format.icon}
                <div>
                  <p className="font-medium text-gray-900 dark:text-white">
                    {format.label}
                  </p>
                  <p className="text-sm text-gray-500 dark:text-gray-400">
                    {format.description}
                  </p>
                </div>
              </div>
            ))}
          </div>
        </div>

        {/* å¯¼å‡ºæŒ‰é’® */}
        <div className="flex justify-end gap-3 pt-4 border-t dark:border-gray-700">
          <button
            onClick={onClose}
            className="px-4 py-2 text-gray-600 dark:text-gray-300 
                       hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg"
          >
            å–æ¶ˆ
          </button>
          <button
            onClick={handleExport}
            disabled={isExporting}
            className="flex items-center gap-2 px-6 py-2 bg-blue-600 text-white 
                       rounded-lg hover:bg-blue-700 disabled:opacity-50 
                       disabled:cursor-not-allowed transition-colors"
          >
            <FiDownload size={16} />
            {isExporting ? 'å¯¼å‡ºä¸­...' : 'å¯¼å‡º'}
          </button>
        </div>
      </div>
    </Modal>
  );
};

export default ExportDialog;
```

### 6. å‰ç«¯ - çŠ¶æ€ç®¡ç†

```ts
// src/stores/editorStore.ts
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface Document {
  id: string;
  title: string;
  content: string;
  createdAt: number;
  updatedAt: number;
}

interface EditorState {
  content: string;
  wordCount: number;
  currentDocument: Document | null;
  documents: Document[];
  isDirty: boolean;
  
  // Actions
  setContent: (content: string) => void;
  setWordCount: (count: number) => void;
  insertText: (text: string) => void;
  createDocument: (title?: string) => void;
  saveDocument: () => void;
  loadDocument: (id: string) => void;
  deleteDocument: (id: string) => void;
}

export const useEditorStore = create<EditorState>()(
  persist(
    (set, get) => ({
      content: '# æ¬¢è¿ä½¿ç”¨ MarkFlow\n\nå¼€å§‹ç¼–å†™ä½ çš„ Markdown æ–‡æ¡£å§ï¼\n\n## åŠŸèƒ½ç‰¹æ€§\n\n- âœï¸ å®æ—¶é¢„è§ˆ\n- ğŸ“„ å¯¼å‡º Word\n- ğŸ“Š å¯¼å‡º Excel\n- ğŸ“‘ å¯¼å‡º PDF\n- ğŸŒ™ æš—é»‘æ¨¡å¼\n\n## ç¤ºä¾‹è¡¨æ ¼\n\n| åŠŸèƒ½ | çŠ¶æ€ | è¯´æ˜ |\n| --- | --- | --- |\n| Markdown ç¼–è¾‘ | âœ… | æ”¯æŒ GFM |\n| å®æ—¶é¢„è§ˆ | âœ… | åˆ†å±æ˜¾ç¤º |\n| Word å¯¼å‡º | âœ… | .docx æ ¼å¼ |\n| Excel å¯¼å‡º | âœ… | .xlsx æ ¼å¼ |\n\n```javascript\nconsole.log("Hello, MarkFlow!");\n```\n',
      wordCount: 0,
      currentDocument: null,
      documents: [],
      isDirty: false,

      setContent: (content) => set({ content, isDirty: true }),
      
      setWordCount: (wordCount) => set({ wordCount }),
      
      insertText: (text) => {
        // è¿™é‡Œéœ€è¦ä¸ CodeMirror ç¼–è¾‘å™¨å®ä¾‹é…åˆ
        // é€šè¿‡äº‹ä»¶æ€»çº¿æˆ– ref æ¥å®é™…æ’å…¥æ–‡æœ¬
        const event = new CustomEvent('editor:insert', { detail: text });
        window.dispatchEvent(event);
      },

      createDocument: (title = 'æœªå‘½åæ–‡æ¡£') => {
        const doc: Document = {
          id: Date.now().toString(36),
          title,
          content: '',
          createdAt: Date.now(),
          updatedAt: Date.now(),
        };
        set((state) => ({
          documents: [...state.documents, doc],
          currentDocument: doc,
          content: doc.content,
          isDirty: false,
        }));
      },

      saveDocument: () => {
        const { currentDocument, content, documents } = get();
        if (!currentDocument) return;
        
        const updated = {
          ...currentDocument,
          content,
          updatedAt: Date.now(),
        };
        set({
          currentDocument: updated,
          documents: documents.map((d) =>
            d.id === updated.id ? updated : d
          ),
          isDirty: false,
        });
      },

      loadDocument: (id) => {
        const doc = get().documents.find((d) => d.id === id);
        if (doc) {
          set({ currentDocument: doc, content: doc.content, isDirty: false });
        }
      },

      deleteDocument: (id) => {
        set((state) => ({
          documents: state.documents.filter((d) => d.id !== id),
          currentDocument:
            state.currentDocument?.id === id ? null : state.currentDocument,
        }));
      },
    }),
    {
      name: 'markflow-editor',
      partialize: (state) => ({
        documents: state.documents,
        content: state.content,
      }),
    }
  )
);
```

### 7. å‰ç«¯ - å¯¼å‡º Hook

```ts
// src/hooks/useExport.ts
import { useCallback } from 'react';
import { saveAs } from 'file-saver';
import { useEditorStore } from '../stores/editorStore';
import { exportApi } from '../services/export.api';

type ExportFormat = 'docx' | 'xlsx' | 'pdf' | 'html' | 'md';

export function useExport() {
  const { content } = useEditorStore();

  const exportDocument = useCallback(
    async (format: ExportFormat, fileName: string) => {
      // Markdown ç›´æ¥åœ¨å‰ç«¯å¤„ç†
      if (format === 'md') {
        const blob = new Blob([content], { type: 'text/markdown;charset=utf-8' });
        saveAs(blob, `${fileName}.md`);
        return;
      }

      // HTML ä¹Ÿå¯ä»¥åœ¨å‰ç«¯å¤„ç†
      if (format === 'html') {
        const { marked } = await import('marked');
        const htmlContent = marked.parse(content);
        const fullHtml = `
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${fileName}</title>
  <style>
    body { 
      max-width: 800px; margin: 0 auto; padding: 40px 20px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      line-height: 1.6; color: #333;
    }
    h1, h2, h3 { border-bottom: 1px solid #eee; padding-bottom: 0.3em; }
    code { background: #f5f5f5; padding: 2px 6px; border-radius: 3px; }
    pre { background: #f5f5f5; padding: 16px; border-radius: 6px; overflow-x: auto; }
    table { border-collapse: collapse; width: 100%; }
    th, td { border: 1px solid #ddd; padding: 8px 12px; text-align: left; }
    th { background: #f5f5f5; }
    blockquote { border-left: 4px solid #ddd; margin: 0; padding-left: 16px; color: #666; }
    img { max-width: 100%; }
  </style>
</head>
<body>${htmlContent}</body>
</html>`;
        const blob = new Blob([fullHtml], { type: 'text/html;charset=utf-8' });
        saveAs(blob, `${fileName}.html`);
        return;
      }

      // Word / Excel / PDF å‘é€åˆ°åç«¯å¤„ç†
      try {
        const response = await exportApi.export({
          content,
          format,
          fileName,
        });

        const mimeTypes: Record<string, string> = {
          docx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
          xlsx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
          pdf: 'application/pdf',
        };

        const blob = new Blob([response.data], { type: mimeTypes[format] });
        saveAs(blob, `${fileName}.${format}`);
      } catch (error) {
        console.error(`Export to ${format} failed:`, error);
        throw error;
      }
    },
    [content]
  );

  return { exportDocument };
}
```

### 8. å‰ç«¯ - API æœåŠ¡

```ts
// src/services/api.ts
import axios from 'axios';

const api = axios.create({
  baseURL: import.meta.env.VITE_API_URL || 'http://localhost:3001/api',
  timeout: 30000,
});

api.interceptors.response.use(
  (response) => response,
  (error) => {
    console.error('API Error:', error.response?.data || error.message);
    return Promise.reject(error);
  }
);

export default api;

// src/services/export.api.ts
import api from './api';

interface ExportRequest {
  content: string;
  format: string;
  fileName: string;
}

export const exportApi = {
  export: (data: ExportRequest) =>
    api.post('/export', data, {
      responseType: 'arraybuffer',
    }),
};
```

### 9. åç«¯ - æœåŠ¡å…¥å£

```ts
// server/src/index.ts
import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import morgan from 'morgan';
import { exportRouter } from './routes/export.routes';
import { documentRouter } from './routes/document.routes';
import { errorMiddleware } from './middlewares/error.middleware';

const app = express();
const PORT = process.env.PORT || 3001;

// ä¸­é—´ä»¶
app.use(helmet());
app.use(cors({
  origin: process.env.CLIENT_URL || 'http://localhost:5173',
  methods: ['GET', 'POST', 'PUT', 'DELETE'],
}));
app.use(morgan('dev'));
app.use(express.json({ limit: '10mb' }));

// è·¯ç”±
app.use('/api/export', exportRouter);
app.use('/api/documents', documentRouter);

// å¥åº·æ£€æŸ¥
app.get('/api/health', (_req, res) => {
  res.json({ status: 'ok', timestamp: new Date().toISOString() });
});

// é”™è¯¯å¤„ç†
app.use(errorMiddleware);

app.listen(PORT, () => {
  console.log(`ğŸš€ MarkFlow Server running on http://localhost:${PORT}`);
});

export default app;
```

### 10. åç«¯ - å¯¼å‡ºè·¯ç”±å’Œæ§åˆ¶å™¨

```ts
// server/src/routes/export.routes.ts
import { Router } from 'express';
import { ExportController } from '../controllers/export.controller';

const router = Router();
const controller = new ExportController();

router.post('/', controller.exportDocument);

export { router as exportRouter };
```

```ts
// server/src/controllers/export.controller.ts
import { Request, Response, NextFunction } from 'express';
import { WordService } from '../services/word.service';
import { ExcelService } from '../services/excel.service';
import { PdfService } from '../services/pdf.service';

export class ExportController {
  private wordService = new WordService();
  private excelService = new ExcelService();
  private pdfService = new PdfService();

  exportDocument = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const { content, format, fileName } = req.body;

      if (!content || !format) {
        return res.status(400).json({ error: 'ç¼ºå°‘å¿…è¦å‚æ•°: content, format' });
      }

      let buffer: Buffer;
      let contentType: string;
      let extension: string;

      switch (format) {
        case 'docx':
          buffer = await this.wordService.convert(content, fileName);
          contentType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
          extension = 'docx';
          break;

        case 'xlsx':
          buffer = await this.excelService.convert(content, fileName);
          contentType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';
          extension = 'xlsx';
          break;

        case 'pdf':
          buffer = await this.pdfService.convert(content, fileName);
          contentType = 'application/pdf';
          extension = 'pdf';
          break;

        default:
          return res.status(400).json({ error: `ä¸æ”¯æŒçš„æ ¼å¼: ${format}` });
      }

      res.setHeader('Content-Type', contentType);
      res.setHeader(
        'Content-Disposition',
        `attachment; filename="${encodeURIComponent(fileName)}.${extension}"`
      );
      res.send(buffer);
    } catch (error) {
      next(error);
    }
  };
}
```

### 11. åç«¯ - Word å¯¼å‡ºæœåŠ¡ â­

```ts
// server/src/services/word.service.ts
import {
  Document,
  Packer,
  Paragraph,
  TextRun,
  HeadingLevel,
  AlignmentType,
  Table,
  TableRow,
  TableCell,
  WidthType,
  BorderStyle,
  ImageRun,
  ExternalHyperlink,
  LevelFormat,
  convertInchesToTwip,
} from 'docx';
import { marked } from 'marked';

interface ParsedToken {
  type: string;
  text?: string;
  depth?: number;
  items?: any[];
  header?: any[];
  rows?: any[];
  ordered?: boolean;
  tokens?: ParsedToken[];
  lang?: string;
}

export class WordService {
  async convert(markdownContent: string, title: string = 'Document'): Promise<Buffer> {
    const tokens = marked.lexer(markdownContent);
    const children = this.processTokens(tokens);

    const doc = new Document({
      creator: 'MarkFlow',
      title,
      description: 'Generated by MarkFlow',
      styles: {
        paragraphStyles: [
          {
            id: 'codeBlock',
            name: 'Code Block',
            basedOn: 'Normal',
            run: {
              font: 'Consolas',
              size: 20,
              color: '2d2d2d',
            },
            paragraph: {
              spacing: { before: 100, after: 100 },
            },
          },
        ],
      },
      numbering: {
        config: [
          {
            reference: 'ordered-list',
            levels: [
              {
                level: 0,
                format: LevelFormat.DECIMAL,
                text: '%1.',
                alignment: AlignmentType.START,
              },
            ],
          },
        ],
      },
      sections: [
        {
          properties: {
            page: {
              margin: {
                top: convertInchesToTwip(1),
                right: convertInchesToTwip(1),
                bottom: convertInchesToTwip(1),
                left: convertInchesToTwip(1),
              },
            },
          },
          children,
        },
      ],
    });

    return Buffer.from(await Packer.toBuffer(doc));
  }

  private processTokens(tokens: any[]): (Paragraph | Table)[] {
    const elements: (Paragraph | Table)[] = [];

    for (const token of tokens) {
      switch (token.type) {
        case 'heading':
          elements.push(this.createHeading(token));
          break;

        case 'paragraph':
          elements.push(this.createParagraph(token));
          break;

        case 'code':
          elements.push(...this.createCodeBlock(token));
          break;

        case 'list':
          elements.push(...this.createList(token));
          break;

        case 'table':
          elements.push(this.createTable(token));
          break;

        case 'blockquote':
          elements.push(...this.createBlockquote(token));
          break;

        case 'hr':
          elements.push(
            new Paragraph({
              border: {
                bottom: { style: BorderStyle.SINGLE, size: 1, color: 'cccccc' },
              },
              spacing: { before: 200, after: 200 },
            })
          );
          break;

        case 'space':
          elements.push(new Paragraph({ text: '' }));
          break;
      }
    }

    return elements;
  }

  private createHeading(token: any): Paragraph {
    const headingMap: Record<number, (typeof HeadingLevel)[keyof typeof HeadingLevel]> = {
      1: HeadingLevel.HEADING_1,
      2: HeadingLevel.HEADING_2,
      3: HeadingLevel.HEADING_3,
      4: HeadingLevel.HEADING_4,
      5: HeadingLevel.HEADING_5,
      6: HeadingLevel.HEADING_6,
    };

    return new Paragraph({
      heading: headingMap[token.depth] || HeadingLevel.HEADING_1,
      children: this.parseInlineTokens(token.tokens || []),
      spacing: { before: 240, after: 120 },
    });
  }

  private createParagraph(token: any): Paragraph {
    return new Paragraph({
      children: this.parseInlineTokens(token.tokens || []),
      spacing: { after: 120 },
    });
  }

  private createCodeBlock(token: any): Paragraph[] {
    const lines = token.text.split('\n');
    return lines.map(
      (line: string) =>
        new Paragraph({
          style: 'codeBlock',
          children: [
            new TextRun({
              text: line || ' ',
              font: 'Consolas',
              size: 20,
            }),
          ],
          shading: { fill: 'f5f5f5' },
        })
    );
  }

  private createList(token: any): Paragraph[] {
    const items: Paragraph[] = [];
    const isOrdered = token.ordered;

    token.items.forEach((item: any, index: number) => {
      const prefix = isOrdered ? `${index + 1}. ` : 'â€¢ ';
      items.push(
        new Paragraph({
          children: [
            new TextRun({ text: prefix }),
            ...this.parseInlineTokens(item.tokens?.[0]?.tokens || []),
          ],
          indent: { left: convertInchesToTwip(0.5) },
          spacing: { after: 60 },
        })
      );
    });

    return items;
  }

  private createTable(token: any): Table {
    const headerRow = new TableRow({
      tableHeader: true,
      children: token.header.map(
        (cell: any) =>
          new TableCell({
            children: [
              new Paragraph({
                children: this.parseInlineTokens(cell.tokens || []),
              }),
            ],
            shading: { fill: 'f0f0f0' },
            width: { size: 100 / token.header.length, type: WidthType.PERCENTAGE },
          })
      ),
    });

    const dataRows = token.rows.map(
      (row: any[]) =>
        new TableRow({
          children: row.map(
            (cell: any) =>
              new TableCell({
                children: [
                  new Paragraph({
                    children: this.parseInlineTokens(cell.tokens || []),
                  }),
                ],
                width: { size: 100 / row.length, type: WidthType.PERCENTAGE },
              })
          ),
        })
    );

    return new Table({
      rows: [headerRow, ...dataRows],
      width: { size: 100, type: WidthType.PERCENTAGE },
    });
  }

  private createBlockquote(token: any): Paragraph[] {
    const paragraphs: Paragraph[] = [];
    
    if (token.tokens) {
      for (const t of token.tokens) {
        paragraphs.push(
          new Paragraph({
            children: this.parseInlineTokens(t.tokens || []),
            indent: { left: convertInchesToTwip(0.5) },
            border: {
              left: { style: BorderStyle.SINGLE, size: 3, color: '999999' },
            },
            spacing: { after: 60 },
          })
        );
      }
    }

    return paragraphs;
  }

  private parseInlineTokens(tokens: any[]): TextRun[] {
    const runs: TextRun[] = [];

    for (const token of tokens) {
      switch (token.type) {
        case 'text':
          runs.push(new TextRun({ text: token.text }));
          break;
        case 'strong':
          runs.push(new TextRun({ text: token.text, bold: true }));
          break;
        case 'em':
          runs.push(new TextRun({ text: token.text, italics: true }));
          break;
        case 'codespan':
          runs.push(
            new TextRun({
              text: token.text,
              font: 'Consolas',
              size: 20,
              shading: { fill: 'f0f0f0' },
            })
          );
          break;
        case 'del':
          runs.push(new TextRun({ text: token.text, strike: true }));
          break;
        case 'link':
          runs.push(
            new TextRun({
              text: token.text,
              color: '0366d6',
              underline: { type: 'single' },
            })
          );
          break;
        default:
          if (token.text) {
            runs.push(new TextRun({ text: token.text }));
          }
      }
    }

    return runs.length > 0 ? runs : [new TextRun({ text: '' })];
  }
}
```

### 12. åç«¯ - Excel å¯¼å‡ºæœåŠ¡ â­

```ts
// server/src/services/excel.service.ts
import ExcelJS from 'exceljs';
import { marked } from 'marked';

interface TableData {
  headers: string[];
  rows: string[][];
  title?: string;
}

export class ExcelService {
  async convert(markdownContent: string, fileName: string = 'Document'): Promise<Buffer> {
    const tables = this.extractTables(markdownContent);
    const workbook = new ExcelJS.Workbook();

    workbook.creator = 'MarkFlow';
    workbook.created = new Date();

    if (tables.length === 0) {
      // æ²¡æœ‰è¡¨æ ¼æ—¶ï¼Œå°†å…¨éƒ¨å†…å®¹ä»¥æ–‡æœ¬å½¢å¼å†™å…¥
      const sheet = workbook.addWorksheet('æ–‡æ¡£å†…å®¹');
      this.writeContentAsText(sheet, markdownContent);
    } else {
      // æ¯ä¸ªè¡¨æ ¼ä¸€ä¸ª sheet
      tables.forEach((table, index) => {
        const sheetName = table.title || `è¡¨æ ¼ ${index + 1}`;
        const sheet = workbook.addWorksheet(sheetName.substring(0, 31)); // Excel sheet name limit
        this.writeTable(sheet, table);
      });
    }

    const buffer = await workbook.xlsx.writeBuffer();
    return Buffer.from(buffer);
  }

  private extractTables(markdown: string): TableData[] {
    const tokens = marked.lexer(markdown);
    const tables: TableData[] = [];
    let lastHeading = '';

    for (const token of tokens) {
      if (token.type === 'heading') {
        lastHeading = (token as any).text;
      }

      if (token.type === 'table') {
        const tableToken = token as any;
        
        const headers = tableToken.header.map((cell: any) =>
          cell.text || this.extractText(cell.tokens)
        );

        const rows = tableToken.rows.map((row: any[]) =>
          row.map((cell: any) =>
            cell.text || this.extractText(cell.tokens)
          )
        );

        tables.push({
          headers,
          rows,
          title: lastHeading || undefined,
        });
      }
    }

    return tables;
  }

  private extractText(tokens: any[]): string {
    if (!tokens) return '';
    return tokens.map((t: any) => t.text || t.raw || '').join('');
  }

  private writeTable(sheet: ExcelJS.Worksheet, table: TableData): void {
    // å†™å…¥æ ‡é¢˜è¡Œ
    const headerRow = sheet.addRow(table.headers);
    headerRow.eachCell((cell) => {
      cell.fill = {
        type: 'pattern',
        pattern: 'solid',
        fgColor: { argb: 'FF4472C4' },
      };
      cell.font = {
        bold: true,
        color: { argb: 'FFFFFFFF' },
        size: 12,
      };
      cell.alignment = {
        horizontal: 'center',
        vertical: 'middle',
      };
      cell.border = {
        top: { style: 'thin' },
        bottom: { style: 'thin' },
        left: { style: 'thin' },
        right: { style: 'thin' },
      };
    });

    // å†™å…¥æ•°æ®è¡Œ
    table.rows.forEach((row, rowIndex) => {
      const dataRow = sheet.addRow(row);
      dataRow.eachCell((cell) => {
        cell.alignment = { vertical: 'middle', wrapText: true };
        cell.border = {
          top: { style: 'thin' },
          bottom: { style: 'thin' },
          left: { style: 'thin' },
          right: { style: 'thin' },
        };
        // äº¤æ›¿è¡Œé¢œè‰²
        if (rowIndex % 2 === 0) {
          cell.fill = {
            type: 'pattern',
            pattern: 'solid',
            fgColor: { argb: 'FFF2F7FB' },
          };
        }
      });
    });

    // è‡ªåŠ¨åˆ—å®½
    sheet.columns.forEach((column, colIndex) => {
      let maxLength = table.headers[colIndex]?.length || 10;
      table.rows.forEach((row) => {
        const cellLength = row[colIndex]?.length || 0;
        if (cellLength > maxLength) maxLength = cellLength;
      });
      column.width = Math.min(Math.max(maxLength + 4, 12), 50);
    });

    // å†»ç»“é¦–è¡Œ
    sheet.views = [{ state: 'frozen', ySplit: 1 }];

    // è‡ªåŠ¨ç­›é€‰
    if (table.headers.length > 0) {
      sheet.autoFilter = {
        from: { row: 1, column: 1 },
        to: { row: 1, column: table.headers.length },
      };
    }
  }

  private writeContentAsText(sheet: ExcelJS.Worksheet, content: string): void {
    const lines = content.split('\n');
    
    sheet.getColumn(1).width = 100;
    
    lines.forEach((line) => {
      const row = sheet.addRow([line]);
      const cell = row.getCell(1);

      // æ£€æµ‹æ ‡é¢˜
      if (line.startsWith('# ')) {
        cell.font = { bold: true, size: 18 };
        cell.value = line.replace(/^#+\s/, '');
      } else if (line.startsWith('## ')) {
        cell.font = { bold: true, size: 16 };
        cell.value = line.replace(/^#+\s/, '');
      } else if (line.startsWith('### ')) {
        cell.font = { bold: true, size: 14 };
        cell.value = line.replace(/^#+\s/, '');
      }
    });
  }
}
```

### 13. åç«¯ - PDF å¯¼å‡ºæœåŠ¡

```ts
// server/src/services/pdf.service.ts
import puppeteer from 'puppeteer';
import { marked } from 'marked';

export class PdfService {
  async convert(markdownContent: string, title: string = 'Document'): Promise<Buffer> {
    const htmlContent = await marked.parse(markdownContent);

    const fullHtml = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>${title}</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700&display=swap');
    
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      font-family: 'Noto Sans SC', -apple-system, BlinkMacSystemFont, sans-serif;
      font-size: 14px;
      line-height: 1.8;
      color: #1a1a1a;
      padding: 40px;
    }
    
    h1 { font-size: 28px; margin: 24px 0 16px; border-bottom: 2px solid #333; padding-bottom: 8px; }
    h2 { font-size: 22px; margin: 20px 0 12px; border-bottom: 1px solid #ddd; padding-bottom: 6px; }
    h3 { font-size: 18px; margin: 16px 0 8px; }
    h4 { font-size: 16px; margin: 12px 0 6px; }
    
    p { margin: 8px 0; }
    
    code {
      background: #f5f5f5;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'Consolas', 'Monaco', monospace;
      font-size: 13px;
    }
    
    pre {
      background: #282c34;
      color: #abb2bf;
      padding: 16px;
      border-radius: 6px;
      overflow-x: auto;
      margin: 12px 0;
    }
    
    pre code {
      background: none;
      padding: 0;
      color: inherit;
    }
    
    table {
      border-collapse: collapse;
      width: 100%;
      margin: 16px 0;
    }
    
    th, td {
      border: 1px solid #ddd;
      padding: 10px 14px;
      text-align: left;
    }
    
    th {
      background: #f5f7fa;
      font-weight: 700;
    }
    
    tr:nth-child(even) { background: #fafafa; }
    
    blockquote {
      border-left: 4px solid #4a90d9;
      margin: 12px 0;
      padding: 8px 16px;
      background: #f8f9fa;
      color: #555;
    }
    
    ul, ol { padding-left: 24px; margin: 8px 0; }
    li { margin: 4px 0; }
    
    hr {
      border: none;
      border-top: 1px solid #ddd;
      margin: 24px 0;
    }
    
    img { max-width: 100%; }
    
    a { color: #4a90d9; text-decoration: none; }
  </style>
</head>
<body>${htmlContent}</body>
</html>`;

    const browser = await puppeteer.launch({
      headless: 'new',
      args: ['--no-sandbox', '--disable-setuid-sandbox'],
    });

    try {
      const page = await browser.newPage();
      await page.setContent(fullHtml, { waitUntil: 'networkidle0' });

      const pdfBuffer = await page.pdf({
        format: 'A4',
        margin: { top: '20mm', right: '15mm', bottom: '20mm', left: '15mm' },
        printBackground: true,
        displayHeaderFooter: true,
        headerTemplate: `
          <div style="font-size:9px; width:100%; text-align:center; color:#999;">
            ${title}
          </div>`,
        footerTemplate: `
          <div style="font-size:9px; width:100%; text-align:center; color:#999;">
            <span class="pageNumber"></span> / <span class="totalPages"></span>
          </div>`,
      });

      return Buffer.from(pdfBuffer);
    } finally {
      await browser.close();
    }
  }
}
```

### 14. åç«¯ - é”™è¯¯ä¸­é—´ä»¶

```ts
// server/src/middlewares/error.middleware.ts
import { Request, Response, NextFunction } from 'express';

export function errorMiddleware(
  err: Error,
  _req: Request,
  res: Response,
  _next: NextFunction
) {
  console.error('âŒ Error:', err.message);
  console.error(err.stack);

  res.status(500).json({
    error: 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯',
    message: process.env.NODE_ENV === 'development' ? err.message : undefined,
  });
}
```

### 15. å‰ç«¯ - è‡ªåŠ¨ä¿å­˜ Hook

```ts
// src/hooks/useAutoSave.ts
import { useEffect, useRef } from 'react';
import { useEditorStore } from '../stores/editorStore';

export function useAutoSave(interval: number = 30000) {
  const { content, isDirty, saveDocument } = useEditorStore();
  const timerRef = useRef<NodeJS.Timeout>();

  useEffect(() => {
    if (!isDirty) return;

    timerRef.current = setTimeout(() => {
      saveDocument();
      console.log('ğŸ“ Auto-saved');
    }, interval);

    return () => {
      if (timerRef.current) clearTimeout(timerRef.current);
    };
  }, [content, isDirty, interval, saveDocument]);

  // Ctrl+S æ‰‹åŠ¨ä¿å­˜
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 's') {
        e.preventDefault();
        saveDocument();
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [saveDocument]);
}
```

### 16. å‰ç«¯ - å¿«æ·é”® Hook

```ts
// src/hooks/useKeyboardShortcuts.ts
import { useEffect } from 'react';

interface Shortcut {
  key: string;
  ctrl?: boolean;
  shift?: boolean;
  alt?: boolean;
  action: () => void;
  description: string;
}

export function useKeyboardShortcuts(shortcuts: Shortcut[]) {
  useEffect(() => {
    const handler = (e: KeyboardEvent) => {
      for (const shortcut of shortcuts) {
        const ctrlMatch = shortcut.ctrl ? (e.ctrlKey || e.metaKey) : true;
        const shiftMatch = shortcut.shift ? e.shiftKey : true;
        const altMatch = shortcut.alt ? e.altKey : true;
        const keyMatch = e.key.toLowerCase() === shortcut.key.toLowerCase();

        if (ctrlMatch && shiftMatch && altMatch && keyMatch) {
          e.preventDefault();
          shortcut.action();
          break;
        }
      }
    };

    window.addEventListener('keydown', handler);
    return () => window.removeEventListener('keydown', handler);
  }, [shortcuts]);
}
```

### 17. å‰ç«¯ - App ä¸»ç»„ä»¶

```tsx
// src/App.tsx
import React from 'react';
import { BrowserRouter, Routes, Route } from 'react-router-dom';
import Layout from './components/Layout/Layout';
import EditorPage from './pages/EditorPage';
import Home from './pages/Home';
import NotFound from './pages/NotFound';
import './styles/globals.css';

const App: React.FC = () => {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<Layout />}>
          <Route index element={<Home />} />
          <Route path="editor" element={<EditorPage />} />
          <Route path="editor/:id" element={<EditorPage />} />
          <Route path="*" element={<NotFound />} />
        </Route>
      </Routes>
    </BrowserRouter>
  );
};

export default App;
```

```tsx
// src/pages/EditorPage.tsx
import React from 'react';
import SplitView from '../components/Editor/SplitView';
import { useAutoSave } from '../hooks/useAutoSave';

const EditorPage: React.FC = () => {
  useAutoSave(30000); // 30s è‡ªåŠ¨ä¿å­˜

  return (
    <div className="h-[calc(100vh-56px)]">
      <SplitView />
    </div>
  );
};

export default EditorPage;
```

### 18. é…ç½®æ–‡ä»¶

```ts
// vite.config.ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
  server: {
    port: 5173,
    proxy: {
      '/api': {
        target: 'http://localhost:3001',
        changeOrigin: true,
      },
    },
  },
});
```

```ts
// tailwind.config.js
/** @type {import('tailwindcss').Config} */
export default {
  content: ['./index.html', './src/**/*.{js,ts,jsx,tsx}'],
  darkMode: 'class',
  theme: {
    extend: {
      typography: {
        DEFAULT: {
          css: {
            maxWidth: 'none',
          },
        },
      },
    },
  },
  plugins: [
    require('@tailwindcss/typography'),
  ],
};
```

```html
<!-- index.html -->
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <title>MarkFlow - Markdown ç¼–è¾‘å™¨</title>
</head>
<body class="bg-white dark:bg-gray-900">
  <div id="root"></div>
  <script type="module" src="/src/main.tsx"></script>
</body>
</html>
```

```env
# .env
VITE_API_URL=http://localhost:3001/api
VITE_APP_NAME=MarkFlow
```

```gitignore
# .gitignore
node_modules/
dist/
server/dist/
.env.local
*.log
.DS_Store
```

---

## ğŸ¨ UI é¢„è§ˆå¸ƒå±€

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ”· MarkFlow    [æˆ‘çš„æ–‡æ¡£ â–¼]              [ğŸŒ™] [â¬‡ å¯¼å‡º]  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  [B] [I] [<>] [ğŸ”—] [ğŸ–¼] [â‰¡] [T] â”‚ [ç¼–è¾‘|åˆ†å±|é¢„è§ˆ] â”‚ 128å­—â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                         â”‚                                â”‚
â”‚  # æˆ‘çš„æ–‡æ¡£              â”‚  æˆ‘çš„æ–‡æ¡£                       â”‚
â”‚                         â”‚  â•â•â•â•â•â•â•â•â•â•â•                   â”‚
â”‚  è¿™æ˜¯ä¸€æ®µ**ç²—ä½“**æ–‡å­—     â”‚  è¿™æ˜¯ä¸€æ®µ ç²—ä½“ æ–‡å­—              â”‚
â”‚                         â”‚                                â”‚
â”‚  ## è¡¨æ ¼ç¤ºä¾‹             â”‚  è¡¨æ ¼ç¤ºä¾‹                       â”‚
â”‚                         â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                    â”‚
â”‚  | å§“å | å¹´é¾„ |         â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚  | --- | --- |          â”‚  â”‚ å§“å  â”‚ å¹´é¾„  â”‚              â”‚
â”‚  | å¼ ä¸‰ | 25  |          â”‚  â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¤              â”‚
â”‚  | æå›› | 30  |          â”‚  â”‚ å¼ ä¸‰  â”‚  25  â”‚              â”‚
â”‚                         â”‚  â”‚ æå››  â”‚  30  â”‚              â”‚
â”‚  ```js                  â”‚  â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚  console.log("hello")   â”‚                                â”‚
â”‚  ```                    â”‚  console.log("hello")          â”‚
â”‚                         â”‚                                â”‚
â”‚          ğŸ“ ç¼–è¾‘å™¨        â”‚ âŸµ  æ‹–æ‹½  âŸ¶â”‚    ğŸ‘ é¢„è§ˆé¢æ¿     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸš€ å¿«é€Ÿå¯åŠ¨

```bash
# 1. å…‹éš†é¡¹ç›®
git clone https://github.com/your-name/markflow.git
cd markflow

# 2. å®‰è£…å‰ç«¯ä¾èµ–
npm install

# 3. å®‰è£…åç«¯ä¾èµ–
cd server && npm install && cd ..

# 4. å¯åŠ¨å¼€å‘ç¯å¢ƒ (å‰åç«¯åŒæ—¶å¯åŠ¨)
npm run dev:all

# å‰ç«¯: http://localhost:5173
# åç«¯: http://localhost:3001
```

---

## ğŸ“‹ åŠŸèƒ½æ¸…å•

| åŠŸèƒ½ | çŠ¶æ€ | è¯´æ˜ |
|------|:----:|------|
| Markdown å®æ—¶ç¼–è¾‘ | âœ… | CodeMirror 6 å†…æ ¸ |
| å®æ—¶é¢„è§ˆ | âœ… | åˆ†å± / çº¯ç¼–è¾‘ / çº¯é¢„è§ˆ |
| GFM æ”¯æŒ | âœ… | è¡¨æ ¼ã€ä»»åŠ¡åˆ—è¡¨ã€åˆ é™¤çº¿ç­‰ |
| ä»£ç é«˜äº® | âœ… | highlight.js æ”¯æŒ 180+ è¯­è¨€ |
| å¯¼å‡º Word (.docx) | âœ… | ä¿ç•™æ ‡é¢˜/è¡¨æ ¼/åˆ—è¡¨/ä»£ç å—æ ·å¼ |
| å¯¼å‡º Excel (.xlsx) | âœ… | è‡ªåŠ¨æå–è¡¨æ ¼ï¼Œæ”¯æŒæ ·å¼ç¾åŒ– |
| å¯¼å‡º PDF | âœ… | Puppeteer æ¸²æŸ“ï¼Œæ”¯æŒé¡µçœ‰é¡µè„š |
| å¯¼å‡º HTML | âœ… | å®Œæ•´ç‹¬ç«‹ HTML æ–‡ä»¶ |
| ä¿å­˜ .md æ–‡ä»¶ | âœ… | å‰ç«¯ç›´æ¥ä¸‹è½½ |
| æš—é»‘æ¨¡å¼ | âœ… | ä¸€é”®åˆ‡æ¢ |
| è‡ªåŠ¨ä¿å­˜ | âœ… | LocalStorage æŒä¹…åŒ– |
| å¿«æ·é”® | âœ… | Ctrl+S / Ctrl+B / Ctrl+I ç­‰ |
| æ–‡æ¡£ç®¡ç† | âœ… | åˆ›å»º/åˆ‡æ¢/åˆ é™¤å¤šä¸ªæ–‡æ¡£ |
| å·¥å…·æ å¿«æ·æ’å…¥ | âœ… | æ ‡é¢˜/ç²—ä½“/é“¾æ¥/è¡¨æ ¼ä¸€é”®æ’å…¥ |
| æ‹–æ‹½åˆ†å± | âœ… | å¯è°ƒèŠ‚ç¼–è¾‘/é¢„è§ˆé¢æ¿æ¯”ä¾‹ |
| Mermaid å›¾è¡¨ | ğŸ”² | æµç¨‹å›¾ / æ—¶åºå›¾æ”¯æŒ (è§„åˆ’ä¸­) |
| ååŒç¼–è¾‘ | ğŸ”² | WebSocket å¤šäººååŒ (è§„åˆ’ä¸­) |
| å›¾ç‰‡ä¸Šä¼  | ğŸ”² | æ‹–æ‹½ / ç²˜è´´ä¸Šä¼ å›¾ç‰‡ (è§„åˆ’ä¸­) |

---

> **MarkFlow** â€” è®© Markdown å†™ä½œæ›´æµç•…ï¼Œè®©æ–‡æ¡£å¯¼å‡ºæ›´ç®€å•ã€‚ âœ¨