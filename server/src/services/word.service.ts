import {
  Document,
  Packer,
  Paragraph,
  TextRun,
  HeadingLevel,
  AlignmentType,
  Table,
  TableRow,
  TableCell,
  WidthType,
  BorderStyle,
  LevelFormat,
  convertInchesToTwip,
} from 'docx';
import { marked } from 'marked';

export class WordService {
  async convert(markdownContent: string, title: string = 'Document'): Promise<Buffer> {
    const tokens = marked.lexer(markdownContent);
    const children = this.processTokens(tokens);

    const doc = new Document({
      creator: 'MarkFlow',
      title,
      description: 'Generated by MarkFlow',
      styles: {
        paragraphStyles: [
          {
            id: 'codeBlock',
            name: 'Code Block',
            basedOn: 'Normal',
            run: {
              font: 'Consolas',
              size: 20,
              color: '2d2d2d',
            },
            paragraph: {
              spacing: { before: 100, after: 100 },
            },
          },
        ],
      },
      numbering: {
        config: [
          {
            reference: 'ordered-list',
            levels: [
              {
                level: 0,
                format: LevelFormat.DECIMAL,
                text: '%1.',
                alignment: AlignmentType.START,
              },
            ],
          },
        ],
      },
      sections: [
        {
          properties: {
            page: {
              margin: {
                top: convertInchesToTwip(1),
                right: convertInchesToTwip(1),
                bottom: convertInchesToTwip(1),
                left: convertInchesToTwip(1),
              },
            },
          },
          children,
        },
      ],
    });

    return Buffer.from(await Packer.toBuffer(doc));
  }

  private processTokens(tokens: any[]): (Paragraph | Table)[] {
    const elements: (Paragraph | Table)[] = [];

    for (const token of tokens) {
      switch (token.type) {
        case 'heading':
          elements.push(this.createHeading(token));
          break;
        case 'paragraph':
          elements.push(this.createParagraph(token));
          break;
        case 'code':
          elements.push(...this.createCodeBlock(token));
          break;
        case 'list':
          elements.push(...this.createList(token));
          break;
        case 'table':
          elements.push(this.createTable(token));
          break;
        case 'blockquote':
          elements.push(...this.createBlockquote(token));
          break;
        case 'hr':
          elements.push(
            new Paragraph({
              border: {
                bottom: { style: BorderStyle.SINGLE, size: 1, color: 'cccccc' },
              },
              spacing: { before: 200, after: 200 },
            })
          );
          break;
        case 'space':
          elements.push(new Paragraph({ text: '' }));
          break;
      }
    }

    return elements;
  }

  private createHeading(token: any): Paragraph {
    const headingMap: Record<number, (typeof HeadingLevel)[keyof typeof HeadingLevel]> = {
      1: HeadingLevel.HEADING_1,
      2: HeadingLevel.HEADING_2,
      3: HeadingLevel.HEADING_3,
      4: HeadingLevel.HEADING_4,
      5: HeadingLevel.HEADING_5,
      6: HeadingLevel.HEADING_6,
    };

    return new Paragraph({
      heading: headingMap[token.depth] || HeadingLevel.HEADING_1,
      children: this.parseInlineTokens(token.tokens || []),
      spacing: { before: 240, after: 120 },
    });
  }

  private createParagraph(token: any): Paragraph {
    return new Paragraph({
      children: this.parseInlineTokens(token.tokens || []),
      spacing: { after: 120 },
    });
  }

  private createCodeBlock(token: any): Paragraph[] {
    const lines = token.text.split('\n');
    return lines.map(
      (line: string) =>
        new Paragraph({
          style: 'codeBlock',
          children: [
            new TextRun({
              text: line || ' ',
              font: 'Consolas',
              size: 20,
            }),
          ],
          shading: { fill: 'f5f5f5' },
        })
    );
  }

  private createList(token: any): Paragraph[] {
    const items: Paragraph[] = [];
    const isOrdered = token.ordered;

    token.items.forEach((item: any, index: number) => {
      const prefix = isOrdered ? `${index + 1}. ` : '\u2022 ';
      items.push(
        new Paragraph({
          children: [
            new TextRun({ text: prefix }),
            ...this.parseInlineTokens(item.tokens?.[0]?.tokens || []),
          ],
          indent: { left: convertInchesToTwip(0.5) },
          spacing: { after: 60 },
        })
      );
    });

    return items;
  }

  private createTable(token: any): Table {
    const headerRow = new TableRow({
      tableHeader: true,
      children: token.header.map(
        (cell: any) =>
          new TableCell({
            children: [
              new Paragraph({
                children: this.parseInlineTokens(cell.tokens || []),
              }),
            ],
            shading: { fill: 'f0f0f0' },
            width: { size: 100 / token.header.length, type: WidthType.PERCENTAGE },
          })
      ),
    });

    const dataRows = token.rows.map(
      (row: any[]) =>
        new TableRow({
          children: row.map(
            (cell: any) =>
              new TableCell({
                children: [
                  new Paragraph({
                    children: this.parseInlineTokens(cell.tokens || []),
                  }),
                ],
                width: { size: 100 / row.length, type: WidthType.PERCENTAGE },
              })
          ),
        })
    );

    return new Table({
      rows: [headerRow, ...dataRows],
      width: { size: 100, type: WidthType.PERCENTAGE },
    });
  }

  private createBlockquote(token: any): Paragraph[] {
    const paragraphs: Paragraph[] = [];

    if (token.tokens) {
      for (const t of token.tokens) {
        paragraphs.push(
          new Paragraph({
            children: this.parseInlineTokens(t.tokens || []),
            indent: { left: convertInchesToTwip(0.5) },
            border: {
              left: { style: BorderStyle.SINGLE, size: 3, color: '999999' },
            },
            spacing: { after: 60 },
          })
        );
      }
    }

    return paragraphs;
  }

  private parseInlineTokens(tokens: any[]): TextRun[] {
    const runs: TextRun[] = [];

    for (const token of tokens) {
      switch (token.type) {
        case 'text':
          runs.push(new TextRun({ text: token.text }));
          break;
        case 'strong':
          runs.push(new TextRun({ text: token.text, bold: true }));
          break;
        case 'em':
          runs.push(new TextRun({ text: token.text, italics: true }));
          break;
        case 'codespan':
          runs.push(
            new TextRun({
              text: token.text,
              font: 'Consolas',
              size: 20,
            })
          );
          break;
        case 'del':
          runs.push(new TextRun({ text: token.text, strike: true }));
          break;
        case 'link':
          runs.push(
            new TextRun({
              text: token.text,
              color: '0366d6',
              underline: {},
            })
          );
          break;
        default:
          if (token.text) {
            runs.push(new TextRun({ text: token.text }));
          }
      }
    }

    return runs.length > 0 ? runs : [new TextRun({ text: '' })];
  }
}
